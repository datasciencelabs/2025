<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Final Project – BST 260: Introduction to Data Science</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>


<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-html/tabby.min.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-html-435ba6093e6f0817aa7405139811e7b1.min.css" rel="stylesheet" append-hash="true" data-mode="light">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">


<link rel="stylesheet" href="style.css">
</head>

<body>


<header id="title-block-header">
<h1 class="title">Final Project</h1>

</header>

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#general-instructions" id="toc-general-instructions">General Instructions</a>
  <ul>
  <li><a href="#sections" id="toc-sections">Sections</a>
  <ul>
  <li><a href="#abstract-150-200-words" id="toc-abstract-150-200-words">Abstract (150-200 words)</a></li>
  <li><a href="#introduction-500-600-words" id="toc-introduction-500-600-words">Introduction (500-600 words)</a></li>
  <li><a href="#methods-600-700-words" id="toc-methods-600-700-words">Methods (600-700 words)</a></li>
  <li><a href="#results-500-600-words" id="toc-results-500-600-words">Results (500-600 words)</a></li>
  <li><a href="#discussion-600-700-words" id="toc-discussion-600-700-words">Discussion (600-700 words)</a></li>
  </ul></li>
  <li><a href="#supplementary-methods-no-limit" id="toc-supplementary-methods-no-limit">Supplementary Methods (no limit)</a></li>
  <li><a href="#examples" id="toc-examples">Examples</a></li>
  <li><a href="#githut-repository" id="toc-githut-repository">GitHut Repository</a></li>
  </ul></li>
  <li><a href="#covid-19" id="toc-covid-19">Covid-19</a>
  <ul>
  <li><a href="#data" id="toc-data">Data</a></li>
  <li><a href="#tasks-and-questions" id="toc-tasks-and-questions">Tasks and questions</a></li>
  </ul></li>
  <li><a href="#excess-mortality" id="toc-excess-mortality">Excess mortality</a>
  <ul>
  <li><a href="#data-1" id="toc-data-1">Data</a></li>
  <li><a href="#tasks-and-questions-1" id="toc-tasks-and-questions-1">Tasks and questions</a></li>
  </ul></li>
  <li><a href="#sec-dashboard" id="toc-sec-dashboard">Election Dashboard</a>
  <ul>
  <li><a href="#data-2" id="toc-data-2">Data</a></li>
  <li><a href="#tasks-and-questions-2" id="toc-tasks-and-questions-2">Tasks and questions</a></li>
  <li><a href="#github" id="toc-github">GitHub</a></li>
  </ul></li>
  </ul>
</nav>
<h1 id="general-instructions">General Instructions</h1>
<p>For the final project you will choose one of these topics:</p>
<ol type="1">
<li>COVID-19 pandemic in the US</li>
<li>Excess mortality in Puerto Rico after Hurricane María.</li>
<li>Topic of your choice (needs instructor approval).</li>
<li>Election results dashboard.</li>
</ol>
<p>You will submit your project using Git. Your project should be completely reproducible, meaning all the code and data needed to render your report from scratch should be in the repository.</p>
<p>You can work alone or in groups of at most three people.</p>
<p>If you select option 4 you can skip to <a href="#sec-dashboard">Election Dashboard</a>.</p>
<h2 id="sections" class="anchored">Sections</h2>
<p>For the first three options, you will prepare a comprehensive report following the style of an academic paper. This report will be divided into the following five structured sections, with approximate word counts to help you reach a target of 2,500 to 3,000 words, up to four figures and up to two tables.</p>
<h3 class="nonumber anchored" id="abstract-150-200-words">Abstract (150-200 words)</h3>
<ul>
<li><strong>Purpose</strong>: The abstract provides a concise summary of your project, including its objectives, key findings, and significance. Write this section last, after completing all other sections, to accurately reflect your project’s focus and main results.</li>
<li><strong>Guidelines</strong>: Limit this section to 150-200 words. Briefly outline the purpose of your study, the approach you used, and the primary results and conclusions. The abstract should be clear, succinct, and give readers an immediate understanding of what your project entails.</li>
</ul>
<h3 class="nonumber anchored" id="introduction-500-600-words">Introduction (500-600 words)</h3>
<ul>
<li><strong>Purpose</strong>: The introduction sets the stage for your project, presenting the background and rationale for your analysis. Explain why the topic is significant.</li>
<li><strong>Guidelines</strong>: Start with a broad overview of the topic, gradually narrowing down to your specific focus. Conclude with a clear statement of your research questions, hypotheses, or objectives. Use 2-3 paragraphs to establish a solid foundation for the rest of the paper.</li>
</ul>
<h3 class="nonumber anchored" id="methods-600-700-words">Methods (600-700 words)</h3>
<ul>
<li><strong>Purpose</strong>: This section details the data sources, methods, and analytical techniques you used to conduct your analysis. It should be specific enough that someone else could replicate your study using the same resources and approach.</li>
<li><strong>Guidelines</strong>: Describe the dataset(s) you used, including information about data collection (e.g., sources, time frame). Outline your approach for cleaning and analyzing the data, including any statistical or computational methods applied. Clearly explain any assumptions or limitations in your approach.</li>
</ul>
<h3 class="nonumber anchored" id="results-500-600-words">Results (500-600 words)</h3>
<ul>
<li><strong>Purpose</strong>: The results section presents the main findings of your analysis without interpretation. Organize the data logically to highlight key insights, using tables, figures, and charts to illustrate trends and comparisons.</li>
<li><strong>Guidelines</strong>: For each result, briefly describe it and refer to relevant visuals or tables where appropriate. Do not provide explanations or discuss implications in this section; focus only on presenting the findings clearly and accurately.</li>
</ul>
<h3 class="nonumber anchored" id="discussion-600-700-words">Discussion (600-700 words)</h3>
<ul>
<li><strong>Purpose</strong>: In the discussion, interpret the significance of your findings, explore potential implications, and relate the results back to your initial research questions or hypotheses. This section allows you to discuss any patterns, unexpected findings, or limitations and suggest possible future research.</li>
<li><strong>Guidelines</strong>: Analyze your results in the context of your research question, linking them back to the background information from the introduction. Consider what your findings reveal, any limitations they may have, and how they might impact future work or policy. End with a brief conclusion summarizing your main insights.</li>
</ul>
<p>Your final report should be professionally formatted, with each section clearly labeled and referenced. Aim for clarity, precision, and a well-organized presentation of your analysis.</p>
<p><strong>Total Word Count</strong>: Approximately 2,500-3,000 words.</p>
<h2 class="nonumber anchored" id="supplementary-methods-no-limit">Supplementary Methods (no limit)</h2>
<p>You can include a <strong>separate document</strong> titled Supplementary Methods.</p>
<ul>
<li><p><strong>Purpose</strong>: Share any mathematical derivations, data visualizations, or tables needed to justify the choices described in the Methods Section. You can also provide further support for the claims made in the Results Section. You can refer to this document in the main report.</p></li>
<li><p><strong>Guidelines</strong>: There is no limits in the length of this section nor on the number of figures and tables. However, be careful not to drown the graders with too much information.</p></li>
</ul>
<h2 id="examples" class="anchored">Examples</h2>
<p>Here are two examples or papers related to the two first topics:</p>
<ul>
<li><a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC10200579/">A Flexible Statistical Framework for Estimating Excess Mortality</a></li>
<li><a href="https://www.bmj.com/content/373/bmj.n1137">Excess deaths associated with covid-19 pandemic in 2020: age and sex disaggregated time series analysis in 29 high income countries</a></li>
</ul>
<h2 class="nonumber anchored" id="githut-repository">GitHut Repository</h2>
<p>We recommend your repository include:</p>
<ul>
<li>Directories <code>code</code>, <code>data</code>, and <code>docs</code>.</li>
<li>At least one script for wrangling in the <code>code</code> directory.</li>
<li>There should be one file called <code>final-project.qmd</code> that can be rendered to produce the final report. This can be in the <code>code</code> or home directories as long as it renders.</li>
<li>You should include a <code>README</code> file explaining how to reproduce all the results.</li>
<li>If you need to share raw data include it in the <code>raw-data</code> directory. Alternatively, you can include code that downloads the necessary data from the internet.</li>
</ul>
<p>We expect to see at least five commits by each person.</p>
<h1 id="covid-19">Covid-19</h1>
<h2 id="data" class="anchored">Data</h2>
<p>You can use the data we downloaded in problem set 4.</p>
<p>We want you to examine the entire pandemic, until at least December 1, 2024 which means you will need to obtain population estimates for 2023 and 2024.</p>
<p><strong>For those working in groups</strong> we want you to obtain daily or weekly mortality data for each state.</p>
<h2 id="tasks-and-questions" class="anchored">Tasks and questions</h2>
<ol type="1">
<li><p>Divide the pandemic period, January 2020 to December 2024 into <em>waves</em>. Justify your choice with data visualization.</p></li>
<li><p>For each period compute the deaths rates by state. Describe which states did better or worse during the different periods.</p></li>
<li><p>Describe if COVID-19 became less or more virulent across the different periods.</p></li>
<li><p><strong>For those working in groups</strong>: Estimate excess mortality for each week for each state. Do COVID-19 deaths explain the excess mortality?</p></li>
<li><p><strong>For those working in groups</strong>: Repeat 2 but for excess mortality instead of COVID-19 deaths.</p></li>
</ol>
<h1 id="excess-mortality">Excess mortality</h1>
<h2 id="data-1" class="anchored">Data</h2>
<p>You can use <code>puerto_rico_counts</code> in the <strong>excessmort</strong> package.</p>
<p><strong>For those working in groups</strong> we want you to wrangle the data from the pdf report shared by the New York Times. <code>https://github.com/c2-d2/pr_mort_official/raw/master/data/Mortalidad-RegDem-2015-17-NYT-part1.pdf</code></p>
<h2 id="tasks-and-questions-1" class="anchored">Tasks and questions</h2>
<ol type="1">
<li><p>Examine the population sizes by age group and sex. Describe any interesting patterns.</p></li>
<li><p>Use data from before 2017 to estimate expected mortality and a standard deviation for each week. Do this by age group and sex. Describe tendencies you observe. You can combine data into bigger age groups if the data show they have similar death rates.</p></li>
<li><p>Explore the data to see if there are periods during or before 2017 that appear to have excess mortality. If so, explain and recompute expected death rates removing these periods.</p></li>
<li><p>Estimate excess deaths for each week of 2017-2018. Make sure you define the weeks so that one of the weeks starts the day María made landfall. Comment on excess mortality. Which age groups were affected? Were men and women affected differently?</p></li>
<li><p><strong>For those working in groups</strong>: Extract the data from the PDF shared with NY Times. Comment on how it matches with <strong>excessmort</strong> package data.</p></li>
</ol>
<h1 id="sec-dashboard">Election Dashboard</h1>
<h2 id="data-2" class="anchored">Data</h2>
<p>Obtain pollster data for 2016, 2018, 2020, 2022 elections. We already provided data from the 2024 election.</p>
<h2 id="tasks-and-questions-2" class="anchored">Tasks and questions</h2>
<ol type="1">
<li><p>We want you to build a shiny dashboard to be ready to predict the 2026 senate election. To do this you will prepare a dashboard for the 2024 senate election.</p></li>
<li><p>The dashboard should show your prediction for each senate race based on a Bayesian analysis.</p></li>
<li><p>The dashboard should also show a prediction for the number of seats the democrats will hold. It should display a histogram with your estimate of the probability distribution for each possible outcome.</p></li>
<li><p>Use data from previous years to motivate the choice of priors.</p></li>
<li><p><strong>For those working in groups</strong>: Use the previous 4 elections to estimate correlations between states in the polling bias. Use it to improve your model.</p></li>
</ol>
<h2 id="github" class="anchored">GitHub</h2>
<p>All the code needed to construct the shiny app should be included in a GitHub repository, including whatever wrangling you performed for your data analysis.</p>


<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
    tabsets.forEach(function(tabset) {
      const tabby = new Tabby('#' + tabset.id);
    });
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/datasciencelabs\.github\.io\/2025\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'light-border',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>




</body></html>